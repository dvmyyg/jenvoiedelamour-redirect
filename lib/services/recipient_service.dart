// -------------------------------------------------------------
// üìÑ FICHIER : lib/services/recipient_service.dart
// -------------------------------------------------------------
// üßπ FONCTIONNALIT√âS PRINCIPALES
// -------------------------------------------------------------
// ‚úÖ G√®re les destinataires (autres utilisateurs avec qui l'utilisateur actuel interagit) li√©s √† l'utilisateur authentifi√© (par UID).
// ‚úÖ Interagit avec la sous-collection Firestore users/{userId}/recipients.
// ‚úÖ Fournit des m√©thodes pour r√©cup√©rer, ajouter, mettre √† jour et supprimer des destinataires.
// ‚úÖ Utilise l'UID Firebase du destinataire comme identifiant des documents dans la sous-collection 'recipients'.
// ‚úÖ Utilise les logs internes via DebugLog.
// ‚úÖ D√©pend de FirestoreService pour certaines op√©rations de lecture et suppression.
// -------------------------------------------------------------
// üïì HISTORIQUE DES MODIFICATIONS
// -------------------------------------------------------------
// V004 - Refactor des m√©thodes streamPairedRecipients, getRecipient, deleteRecipient pour utiliser FirestoreService. - 2025/06/18 13h30
// V003 - Ajout de la gestion d'erreurs (try/catch avec FirebaseException) pour les op√©rations Firestore. - 2025/05/30
// V002 - Remplacement de deviceId par l'UID de l'utilisateur authentifi√© pour l'acc√®s Firestore (users/{userId}/recipients). Adaptation des requ√™tes. - 2025/05/29
// V001 - Version initiale (bas√©e sur deviceId)
// -------------------------------------------------------------

// GEM - code corrig√© par G√©mini le 2025/05/30 // Mise √† jour de la date au 30/05

import 'package:cloud_firestore/cloud_firestore.dart';
import '../models/recipient.dart'; // Utilise le mod√®le Recipient refactoris√©
import '../utils/debug_log.dart';
import 'firestore_service.dart'; // ‚úÖ AJOUT V004 : Import de FirestoreService

class RecipientService {
  // L'identifiant de l'utilisateur actuel (son UID Firebase)
  final String currentUserId;

  // R√©f√©rence √† l'instance Firestore (initialis√©e une fois pour le service)
  // ‚õîÔ∏è √Ä supprimer ‚Äî Remplac√© par l'injection de FirestoreService ‚Äî 2025/06/18
  // final FirebaseFirestore _firestore;
  // ‚õîÔ∏è FIN du bloc √† supprimer ‚Äî 2025/06/18

  // ‚úÖ AJOUT V004 : Champ pour l'instance inject√©e de FirestoreService
  final FirestoreService _firestoreService;


  // Le service est initialis√© avec l'UID de l'utilisateur et FirestoreService
  // üîÑ MODIF V004 : Ajout de la d√©pendance √† FirestoreService
  RecipientService(this.currentUserId, {required FirestoreService firestoreService})
      : _firestoreService = firestoreService; // Initialise l'instance FirestoreService


  // R√©f√©rence √† la sous-collection des destinataires pour l'utilisateur actuel, bas√©e sur son UID
  // Cette r√©f√©rence n'est plus utilis√©e directement pour les op√©rations d√©plac√©es vers FirestoreService
  // mais peut rester pour les m√©thodes qui n'ont pas encore √©t√© refactor√©es (fetch, add, update unilat√©raux).
  CollectionReference get _recipientsRef => FirebaseFirestore.instance
      .collection('users') // Collection de premier niveau bas√©e sur l'UID
      .doc(currentUserId) // Document de l'utilisateur actuel (UID)
      .collection('recipients'); // Sous-collection des destinataires de l'utilisateur actuel


  // ‚úÖ R√©cup√©rer les destinataires appair√©s pour l'utilisateur actuel (m√©thode asynchrone snapshot unique)
  // Cette m√©thode utilise toujours l'acc√®s direct √† Firestore pour l'instant.
  Future<List<Recipient>> fetchRecipients() async {
    debugLog("üîÑ [fetchRecipients] Chargement des destinataires pour l'utilisateur : $currentUserId");
    try {
      final snapshot = await _recipientsRef
          .where('paired', isEqualTo: true) // ‚úÖ filtre : uniquement ceux qui sont appair√©s
          .get();

      debugLog(
        "‚úÖ [fetchRecipients] ${snapshot.docs.length} destinataires appair√©s r√©cup√©r√©s depuis Firestore pour $currentUserId",
      );

      // Utilise le factory Recipient.fromMap (qui attend l'ID du doc et un Map avec les donn√©es)
      return snapshot.docs
          .map(
            (doc) =>
            Recipient.fromMap(doc.id, doc.data() as Map<String, dynamic>), // Cast s√©curis√©
      )
          .toList();

    } on FirebaseException catch (e) {
      // G√®re les erreurs sp√©cifiques √† Firebase
      debugLog(
        "‚ùå [fetchRecipients] Erreur Firebase lors du chargement des destinataires pour $currentUserId : ${e.code} - ${e.message}",
        level: 'ERROR',
      );
      rethrow; // Rethrow l'exception
    } catch (e) {
      // G√®re toute autre erreur inattendue
      debugLog(
        "‚ùå [fetchRecipients] Erreur inattendue lors du chargement des destinataires pour $currentUserId : $e",
        level: 'ERROR',
      );
      rethrow;
    }
  }

  // ‚úÖ Ajouter un destinataire (pour l'utilisateur actuel) (m√©thode unilat√©rale set avec merge)
  // Cette m√©thode utilise toujours l'acc√®s direct √† Firestore pour l'instant.
  // Le recipient.id doit √™tre l'UID de l'autre utilisateur.
  // Utilise set() avec merge: true pour √©viter d'√©craser d'autres champs si le document existe d√©j√†.
  Future<void> addRecipient(Recipient recipient) async {
    debugLog("üìù [addRecipient] Tentative d'ajout d'un destinataire pour $currentUserId : ${recipient.displayName} (UID: ${recipient.id})"); // ‚úÖ CORRECTION SYNTAXE
    if (recipient.id.isEmpty) {
      debugLog("‚ö†Ô∏è [addRecipient] UID destinataire vide. Ajout annul√©.", level: 'WARN');
      // Optionnel: Lancer une exception ici.
      return;
    }
    try {
      // recipient.id contient maintenant l'UID de l'autre utilisateur
      // set() est utilis√© au cas o√π le document existerait d√©j√† (ex: si l'appairage a d√©j√† cr√©√© le doc)
      await _recipientsRef.doc(recipient.id).set(recipient.toMap(), SetOptions(merge: true));
      debugLog(
        "‚úÖ [addRecipient] Destinataire ajout√©/mis √† jour pour $currentUserId : ${recipient.displayName} (UID: ${recipient.id})",
      );
    } on FirebaseException catch (e) {
      debugLog(
        "‚ùå [addRecipient] Erreur Firebase lors de l'ajout destinataire ${recipient.id} pour $currentUserId : ${e.code} - ${e.message}",
        level: 'ERROR',
      );
      rethrow;
    } catch (e) {
      debugLog(
        "‚ùå [addRecipient] Erreur inattendue lors de l'ajout destinataire ${recipient.id} pour $currentUserId : $e",
        level: 'ERROR',
      );
      rethrow;
    }
  }

  // ‚úÖ Mettre √† jour un destinataire (pour l'utilisateur actuel) (m√©thode unilat√©rale update)
  // Cette m√©thode utilise toujours l'acc√®s direct √† Firestore pour l'instant.
  // Le recipient.id doit √™tre l'UID de l'autre utilisateur
  Future<void> updateRecipient(Recipient recipient) async {
    debugLog("üìù [updateRecipient] Tentative de mise √† jour du destinataire pour $currentUserId : ${recipient.displayName} (UID: ${recipient.id})");
    if (recipient.id.isEmpty) {
      debugLog("‚ö†Ô∏è [updateRecipient] UID destinataire vide. Mise √† jour annul√©e.", level: 'WARN');
      // Optionnel: Lancer une exception ici.
      return;
    }
    try {
      // recipient.id contient maintenant l'UID de l'autre utilisateur
      // update() √©chouera si le document n'existe pas. Si vous voulez cr√©er si inexistant, utilisez set(..., merge: true).
      await _recipientsRef.doc(recipient.id).update(recipient.toMap());
      debugLog(
        "‚úÖ [updateRecipient] Destinataire mis √† jour pour $currentUserId : ${recipient.displayName} (UID: ${recipient.id})",
      );
    } on FirebaseException catch (e) {
      debugLog(
        "‚ùå [updateRecipient] Erreur Firebase lors de la mise √† jour destinataire ${recipient.id} pour $currentUserId : ${e.code} - ${e.message}",
        level: 'ERROR',
      );
      // G√©rer l'erreur "document n'existe pas" si n√©cessaire
      if (e.code == 'not-found') {
        debugLog("‚ö†Ô∏è [updateRecipient] Document destinataire ${recipient.id} non trouv√© pour mise √† jour.", level: 'WARN');
        // Optionnel: G√©rer ce cas sp√©cifiquement, peut-√™tre ignorer ou logger diff√©remment.
      }
      rethrow;
    } catch (e) {
      debugLog(
        "‚ùå [updateRecipient] Erreur inattendue lors de la mise √† jour destinataire ${recipient.id} pour $currentUserId : $e",
        level: 'ERROR',
      );
      rethrow;
    }
  }

  // ‚úÖ MODIF V004 : Supprimer un destinataire (pour l'utilisateur actuel)
  // Cette m√©thode utilise maintenant FirestoreService.
  // L'id doit √™tre l'UID de l'autre utilisateur
  Future<void> deleteRecipient(String recipientUserId) async {
    debugLog("üóëÔ∏è [deleteRecipient] Tentative de suppression du destinataire $recipientUserId pour l'utilisateur : $currentUserId");
    if (recipientUserId.isEmpty) {
      debugLog("‚ö†Ô∏è [deleteRecipient] UID destinataire vide. Suppression annul√©e.", level: 'WARN');
      // Optionnel: Lancer une exception ici.
      return;
    }
    try {
      // ‚úÖ Utilise le FirestoreService inject√© pour supprimer le destinataire
      await _firestoreService.deleteRecipient(userId: currentUserId, recipientId: recipientUserId);
      debugLog("‚úÖ [deleteRecipient] Destinataire $recipientUserId supprim√© pour $currentUserId via FirestoreService");
    } on FirebaseException catch (e) {
      debugLog(
        "‚ùå [deleteRecipient] Erreur Firebase lors de la suppression destinataire $recipientUserId pour $currentUserId via FirestoreService : ${e.code} - ${e.message}",
        level: 'ERROR',
      );
      // G√©rer l'erreur "document n'existe pas" si n√©cessaire
      if (e.code == 'not-found') {
        debugLog("‚ö†Ô∏è [deleteRecipient] Document destinataire $recipientUserId non trouv√© pour suppression via FirestoreService.", level: 'WARN');
        // Optionnel: G√©rer ce cas sp√©cifiquement.
      }
      rethrow;
    } catch (e) {
      debugLog(
        "‚ùå [deleteRecipient] Erreur inattendue lors de la suppression destinataire $recipientUserId pour $currentUserId via FirestoreService : $e",
        level: 'ERROR',
      );
      rethrow;
    }
  }

  // ‚úÖ MODIF V004 : Ajouter une m√©thode pour obtenir un stream des destinataires appair√©s (pour l'UI en temps r√©el)
  // Cette m√©thode utilise maintenant FirestoreService.
  Stream<List<Recipient>> streamPairedRecipients() {
    debugLog("üîÑ [streamPairedRecipients] Ouverture du flux des destinataires appair√©s pour l'UID : $currentUserId", level: 'INFO');
    // ‚úÖ Utilise le FirestoreService inject√© pour obtenir le stream
    // Note: FirestoreService.streamRecipients inclut d√©j√† le filtre 'paired: true' et le mapping en List<Recipient>
    return _firestoreService.streamRecipients(currentUserId);
  }

  // ‚úÖ MODIF V004 : Ajouter une m√©thode pour obtenir UN destinataire sp√©cifique par son UID (pour l'√©cran de d√©tails par exemple)
  // Cette m√©thode utilise maintenant FirestoreService.
  Future<Recipient?> getRecipient(String recipientUid) async {
    debugLog("üîÑ [getRecipient] Tentative de chargement du destinataire $recipientUid pour l'UID : $currentUserId", level: 'INFO');
    if (recipientUid.isEmpty) {
      debugLog("‚ö†Ô∏è [getRecipient] UID destinataire vide. Chargement annul√©.", level: 'WARN');
      return null;
    }
    try {
      // ‚úÖ Utilise le FirestoreService inject√© pour obtenir le destinataire
      // FirestoreService.getRecipient retourne Recipient?
      return await _firestoreService.getRecipient(userId: currentUserId, recipientId: recipientUid);
    } on FirebaseException catch (e) {
      debugLog("‚ùå [getRecipient] Erreur Firebase lors du chargement destinataire $recipientUid pour l'UID $currentUserId via FirestoreService : ${e.code} - ${e.message}", level: 'ERROR');
      rethrow;
    } catch (e) {
      debugLog("‚ùå [getRecipient] Erreur inattendue lors du chargement destinataire $recipientUid pour l'UID $currentUserId via FirestoreService : $e", level: 'ERROR');
      rethrow;
    }
  }
}

// üìÑ FIN de lib/services/recipient_service.dart
